from pathlib import Path
from typing import Dict

from eplus_rmd.input_file import InputFile
from eplus_rmd.output_file import OutputFile
from eplus_rmd.validator import Validator


class Translator:
    """This class reads in the input files and does the heavy lifting to write output files"""

    def __init__(self, epjson_file_path: Path):
        print(f"Reading epJSON input file at {str(epjson_file_path)}")
        self.input_file = InputFile(epjson_file_path)
        self.epjson_object = self.input_file.epjson_object
        self.json_results_object = self.input_file.json_results_object
        print(f"Reading EnergyPlus results JSON file: {str(self.input_file.json_results_input_path)}")

        self.output_file = OutputFile(epjson_file_path)
        self.rmd_file_path = self.output_file.rmd_file_path
        print(f"Will write output file to {str(self.rmd_file_path)}")

        self.validator = Validator()

        self.rmd = {}
        self.instance = {}
        self.building = {}
        self.building_segment = {}

    @staticmethod
    def validate_input_contents(input_json: Dict):
        if 'Version' not in input_json:
            raise Exception("Did not find Version key in input file epJSON contents, aborting")
        if 'Version 1' not in input_json['Version']:
            raise Exception("Did not find \"Version 1\" key in input epJSON Version value, aborting")
        if "version_identifier" not in input_json['Version']['Version 1']:
            raise Exception("Did not find \"version_identifier\" key in input epJSON Version value, aborting")

    def get_building_name(self):
        building_input = self.epjson_object['Building']
        return list(building_input.keys())[0]

    def create_skeleton(self):
        self.building_segment = {'id': 'segment 1'}

        self.building = {'id': self.get_building_name(),
                         'notes': 'this file contains only a single building',
                         'building_segments': [self.building_segment, ],
                         'building_open_schedule': 'always_1'}

        self.instance = {'id': 'Only instance',
                         'notes': 'this file contains only a single instance',
                         'buildings': [self.building, ]}

        self.rmd = {'id': 'rmd_root',
                    'notes': 'generated by createRulesetModelDescription from EnergyPlus',
                    'ruleset_model_instances': [self.instance, ]}

    def add_zones(self):
        tabular_reports = self.json_results_object['TabularReports']
        zones = []
        for tabular_report in tabular_reports:
            if tabular_report['ReportName'] == 'Input Verification and Results Summary':
                tables = tabular_report['Tables']
                for table in tables:
                    if table['TableName'] == 'Zone Summary':
                        rows = table['Rows']
                        zone_names = list(rows.keys())
                        zone_names.remove('Total')
                        zone_names.remove('Conditioned Total')
                        zone_names.remove('Unconditioned Total')
                        zone_names.remove('Not Part of Total')
                        # print(zone_names)
                        cols = table['Cols']
                        volume_column = cols.index('Volume [m3]')
                        # print(volume_column)
                        for zone_name in zone_names:
                            zone = {'id': zone_name,
                                    'volume': float(rows[zone_name][volume_column]),
                                    'thermostat_cooling_setpoint_schedule': 'always_70',
                                    'thermostat_heating_setpoint_schedule': 'always_70',
                                    'minimum_humidity_setpoint_schedule': 'always_0_3',
                                    'maximum_humidity_setpoint_schedule': 'always_0_8',
                                    'exhaust_airflow_rate_multiplier_schedule': 'always_1'}
                            zones.append(zone)
                break
        self.building_segment['zones'] = zones

    def add_spaces(self):
        tabular_reports = self.json_results_object['TabularReports']
        spaces = {}
        lights_by_space = self.gather_interior_lighting()
        for tabular_report in tabular_reports:
            if tabular_report['ReportName'] == 'Input Verification and Results Summary':
                tables = tabular_report['Tables']
                for table in tables:
                    if table['TableName'] == 'Space Summary':
                        rows = table['Rows']
                        space_names = list(rows.keys())
                        space_names.remove('Total')
                        space_names.remove('Conditioned Total')
                        space_names.remove('Unconditioned Total')
                        space_names.remove('Not Part of Total')
                        # print(space_names)
                        cols = table['Cols']
                        zone_name_column = cols.index('Zone Name')
                        area_column = cols.index('Area [m2]')
                        people_density_column = cols.index('People [m2 per person]')
                        for space_name in space_names:
                            floor_area = float(rows[space_name][area_column])
                            people_density = float(rows[space_name][people_density_column])
                            if people_density > 0:
                                people = floor_area / people_density
                            else:
                                people = 0
                            space = {'id': space_name, 'floor_area': floor_area,
                                     'number_of_occupants': round(people, 2),
                                     'occupant_multiplier_schedule': 'always_1'}
                            if space_name in lights_by_space:
                                space['interior_lighting'] = lights_by_space[space_name]
                            # print(space, rows[space_name][zone_name_column])
                            spaces[rows[space_name][zone_name_column]] = space
        # insert the space into the corresponding Zone
        for zone in self.building_segment['zones']:
            zone['spaces'] = []
            if zone['id'] in spaces:
                zone['spaces'].append(spaces[zone['id']])

    def gather_interior_lighting(self):
        tabular_reports = self.json_results_object['TabularReports']
        lights = {}  # dictionary by space name containing the lights
        for tabular_report in tabular_reports:
            if tabular_report['ReportName'] == 'LightingSummary':
                tables = tabular_report['Tables']
                for table in tables:
                    if table['TableName'] == 'Interior Lighting':
                        rows = table['Rows']
                        int_light_names = list(rows.keys())
                        int_light_names.remove('Interior Lighting Total')
                        cols = table['Cols']
                        space_name_column = cols.index('Space Name')
                        zone_name_column = cols.index('Zone Name')
                        schedule_name_column = cols.index('Schedule Name')
                        power_density_column = cols.index('Lighting Power Density [W/m2]')
                        for int_light_name in int_light_names:
                            power_density = float(rows[int_light_name][power_density_column])
                            space_name = rows[int_light_name][space_name_column]
                            schedule_name = rows[int_light_name][schedule_name_column]
                            light = {'id': int_light_name,
                                     'power_per_area': power_density,
                                     'lighting_multiplier_schedule': schedule_name}
                            # print(light)
                            if space_name not in lights:
                                lights[space_name] = [light, ]
                            else:
                                lights[space_name].append(light)
        return lights

    def process(self):
        epjson = self.epjson_object
        Translator.validate_input_contents(epjson)
        # version_id = epjson['Version']['Version 1']['version_identifier']
        self.create_skeleton()
        self.add_zones()
        self.add_spaces()
        self.validator.validate_rmd(self.rmd)
        self.output_file.write(self.rmd)
